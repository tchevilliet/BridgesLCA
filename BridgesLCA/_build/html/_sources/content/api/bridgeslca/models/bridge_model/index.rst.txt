bridgeslca.models.bridge_model
==============================

.. py:module:: bridgeslca.models.bridge_model

.. autoapi-nested-parse::

   Created on Tue Oct  8 17:50:06 2024

   @author: thibault.chevilliet



Attributes
----------

.. autoapisummary::

   bridgeslca.models.bridge_model.D
   bridgeslca.models.bridge_model.m


Classes
-------

.. autoapisummary::

   bridgeslca.models.bridge_model.Demand
   bridgeslca.models.bridge_model.IRI
   bridgeslca.models.bridge_model.RunConfig
   bridgeslca.models.bridge_model.SentierModel
   bridgeslca.models.bridge_model.SimpleDataRange


Functions
---------

.. autoapisummary::

   bridgeslca.models.bridge_model.within_interval


Module Contents
---------------

.. py:class:: Demand

   Bases: :py:obj:`pydantic.BaseModel`


   .. py:attribute:: amount
      :type:  float


   .. py:attribute:: length
      :type:  float


   .. py:attribute:: product_iri
      :type:  IRI


   .. py:attribute:: properties
      :type:  Optional[list]


   .. py:attribute:: spatial_context
      :type:  IRI


   .. py:attribute:: temporal_range
      :type:  SimpleDataRange


   .. py:attribute:: tolerance
      :type:  float


   .. py:attribute:: width
      :type:  float


.. py:class:: IRI

   Bases: :py:obj:`pydantic.BaseModel`


   .. py:attribute:: ref
      :type:  str


.. py:class:: RunConfig

   Bases: :py:obj:`pydantic.BaseModel`


   .. py:attribute:: num_samples
      :type:  int
      :value: 1000



   .. py:attribute:: outliers_raise_error
      :type:  bool
      :value: False



.. py:class:: SentierModel(demand: Demand, run_config: RunConfig)

   .. py:method:: check_tolerance() -> list


   .. py:method:: get_model_data(all_data: dict, reported_technology: dict) -> list[pandas.DataFrame]


   .. py:method:: make_the_bridge() -> dict


   .. py:method:: prepare() -> None


   .. py:method:: run(list_uri: dict) -> list[Demand]


   .. py:attribute:: demand


.. py:class:: SimpleDataRange

   Bases: :py:obj:`NamedTuple`


   .. py:attribute:: end
      :type:  datetime.date


   .. py:attribute:: start
      :type:  datetime.date


.. py:function:: within_interval(ref_value: float, target_value: float, tolerance: float) -> bool

.. py:data:: D

.. py:data:: m

